#!/usr/bin/env python3
"""
MiniBook - A tool to create a minibook from a list of links.
Supports both MkDocs and Jinja2/HTML generation.
"""

import argparse
import os
import sys
import shutil
import yaml
from datetime import datetime
from pathlib import Path
from jinja2 import Environment, FileSystemLoader


def generate_html(title, links, description=None, timestamp=None, output_file="minibook.html"):
    """
    Generate an HTML page with the given title and links using Jinja2.

    Args:
        title (str): The title of the webpage
        links (list): A list of tuples with (name, url)
        description (str, optional): A description to include on the page
        timestamp (str, optional): A fixed timestamp for testing purposes
        output_file (str, optional): The output HTML file

    Returns:
        str: The path to the generated HTML file
    """
    # Set up Jinja2 environment
    template_dir = os.path.join(os.path.dirname(__file__), 'templates')
    env = Environment(loader=FileSystemLoader(template_dir))
    template = env.get_template('html.j2')

    # Use the provided timestamp or generate a new one
    if timestamp is None:
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Render the template with our data
    html = template.render(
        title=title,
        links=links,
        description=description,
        timestamp=timestamp
    )

    # Save the HTML to a file
    with open(output_file, 'w') as f:
        f.write(html)

    return output_file


def generate_mkdocs_project(title, links, description=None, timestamp=None, output_dir="minibook_site"):
    """
    Generate a MkDocs project with the given title and links.

    Args:
        title (str): The title of the webpage
        links (list): A list of tuples with (name, url)
        description (str, optional): A description to include on the page
        timestamp (str, optional): A fixed timestamp for testing purposes
        output_dir (str, optional): The directory to create the MkDocs project in

    Returns:
        str: The path to the generated MkDocs project
    """
    # Create the output directory if it doesn't exist
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Create the docs directory
    docs_dir = os.path.join(output_dir, "docs")
    if not os.path.exists(docs_dir):
        os.makedirs(docs_dir)

    # Use the provided timestamp or generate a new one
    if timestamp is None:
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Create the index.md file
    index_content = f"# {title}\n\n"

    if description:
        index_content += f"*{description}*\n\n"

    index_content += "## Links\n\n"

    for name, url in links:
        index_content += f"* [{name}]({url})\n"

    index_content += f"\n\n*Generated by MiniBook on {timestamp}*\n"

    with open(os.path.join(docs_dir, "index.md"), 'w') as f:
        f.write(index_content)

    # Create the mkdocs.yml file
    mkdocs_config = {
        "site_name": title,
        "theme": "material",
        "nav": [
            {"Home": "index.md"}
        ]
    }

    with open(os.path.join(output_dir, "mkdocs.yml"), 'w') as f:
        yaml.dump(mkdocs_config, f, default_flow_style=False)

    return output_dir


def get_links_interactively():
    """
    Prompt the user to enter links interactively.

    Returns:
        list: A list of tuples with (name, url)
    """
    links = []
    print("Enter links (leave URL empty to finish):")

    while True:
        url = input("URL: ").strip()
        if not url:
            break

        name = input("Name (press Enter to use URL as name): ").strip()
        if not name:
            name = url

        links.append((name, url))
        print()

    return links


def main():
    parser = argparse.ArgumentParser(description="Create a minibook from a list of links")
    parser.add_argument("-t", "--title", default="My Links", help="Title of the minibook")
    parser.add_argument("-d", "--description", help="Description of the minibook")
    parser.add_argument("-o", "--output", default="minibook.html", help="Output file or directory")
    parser.add_argument("-l", "--links", nargs="+", help="List of URLs (space-separated)")
    parser.add_argument("--timestamp", help="Fixed timestamp for testing purposes")
    parser.add_argument("--format", choices=["html", "mkdocs"], default="html", 
                        help="Output format: html or mkdocs (default: html)")

    args = parser.parse_args()

    if args.links:
        # Use links provided via command line
        links = [(url, url) for url in args.links]  # (name, url) tuples
    else:
        # Get links interactively
        links = get_links_interactively()

    if not links:
        print("No links provided. Exiting.", file=sys.stderr)
        return 1

    if args.format == "html":
        # Generate HTML using Jinja2
        output_file = args.output
        if os.path.isdir(output_file):
            output_file = os.path.join(output_file, "minibook.html")
        
        output_path = generate_html(
            args.title, 
            links, 
            args.description, 
            args.timestamp, 
            output_file
        )
        print(f"HTML minibook created successfully: {os.path.abspath(output_path)}")
    else:
        # Generate MkDocs project
        output_dir = args.output
        if output_dir.endswith(".html"):
            # If the output is specified as an HTML file but format is mkdocs,
            # use a default directory name
            output_dir = "minibook_site"
        
        output_path = generate_mkdocs_project(
            args.title, 
            links, 
            args.description, 
            args.timestamp, 
            output_dir
        )
        print(f"MkDocs minibook created successfully: {os.path.abspath(output_path)}")
        print(f"To build the site, run: cd {output_path} && mkdocs build")
        print(f"To serve the site locally, run: cd {output_path} && mkdocs serve")

    return 0


if __name__ == '__main__':
    sys.exit(main())